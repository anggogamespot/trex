<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Endless Runner — Chrome Dino Inspired</title>
    <style>
      /* Layout */
      :root {
        color-scheme: light;
      }
      html, body {
        height: 100%;
      }
      body {
        margin: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #f5f7fa;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif;
      }
      .game-container {
        position: relative;
        width: 900px;
        max-width: 95vw;
      }
      canvas {
        display: block;
        width: 100%;
        height: auto;
        background: #fff;
        border: 2px solid #222;
        border-radius: 8px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.08);
      }
      .hud {
        position: absolute;
        top: 8px;
        left: 12px;
        right: 12px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        color: #222;
        font-weight: 700;
        text-shadow: 0 1px 0 rgba(255,255,255,0.8);
        pointer-events: none;
      }
      .overlay {
        position: absolute;
        inset: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 14px;
        background: rgba(255,255,255,0.9);
        color: #111;
      }
      .overlay.hidden { display: none; }
      .overlay .title {
        font-size: 28px;
        font-weight: 800;
      }
      button {
        padding: 10px 16px;
        border-radius: 10px;
        border: 1px solid #222;
        background: #eee;
        cursor: pointer;
        font-weight: 700;
      }
      button:hover { background: #e4e4e4; }
      .loading {
        position: absolute;
        right: 12px;
        bottom: 12px;
        background: #222;
        color: #fff;
        padding: 6px 10px;
        border-radius: 8px;
        font-size: 12px;
      }
    </style>
  </head>
  <body>
    <!--
      Single-file HTML5 Canvas Endless Runner
      - requestAnimationFrame loop with speed increasing over time
      - Space/Up to Jump, Down to Duck (hitbox changes)
      - Obstacles: Cacti (rects) and Pterodactyls (images)
      - Score, collision detection, Game Over and Restart
    -->
    <div class="game-container">
      <canvas id="game" width="900" height="280"></canvas>
      <div class="hud">
        <div>Score: <span id="score">0</span></div>
        <div>High: <span id="high">0</span></div>
      </div>
      <div id="overlay" class="overlay hidden">
        <div class="title" id="message">Game Over</div>
        <button id="restart">Restart</button>
        <div style="font-size:12px;color:#444">Press Space/Enter to restart</div>
      </div>
      <div id="loading" class="loading">Loading images…</div>
    </div>

    <script>
      "use strict";

      // LIST OF GITHUB URLS GOES HERE
      const pterodactylImageURLs = ['https://i.postimg.cc/GBbKGbNQ/hdh.jpg'];
      const DINO_URL = 'https://i.postimg.cc/kV7sK7Z8/trex.gif';

      // Canvas & UI references
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');
      const scoreEl = document.getElementById('score');
      const highEl = document.getElementById('high');
      const overlayEl = document.getElementById('overlay');
      const messageEl = document.getElementById('message');
      const restartBtn = document.getElementById('restart');
      const loadingEl = document.getElementById('loading');

      // World constants
      const groundY = canvas.height - 48; // baseline for ground
      const gravity = 1700;               // px/s^2
      const jumpVelocity = -640;          // px/s upward
      const initialSpeed = 250;           // px/s horizontal world speed
      const speedIncreasePerSecond = 5;   // acceleration over time
      const maxSpeed = 760;               // cap speed

      // Target render sizes for images; drawImage scales down maintaining aspect ratio
      const DINO_TARGET_W = 50;
      const DINO_TARGET_H = 50;
      const PTERO_TARGET_W = 50;
      const PTERO_TARGET_H = 40;

      // Image assets (ensure both fully load before starting the loop)
      const dinoImage = new Image();
      dinoImage.src = DINO_URL;
      dinoImage.crossOrigin = 'anonymous';

      const pteroImage = new Image();
      pteroImage.src = pterodactylImageURLs[0]; // select the URL from the array
      pteroImage.crossOrigin = 'anonymous';

      let assetsLoaded = 0;
      [dinoImage, pteroImage].forEach(img => {
        img.addEventListener('load', () => {
          assetsLoaded++;
          if (assetsLoaded === 2) {
            loadingEl.style.display = 'none';
            // Start immediately when both images are ready
            resetGame();
            lastTime = performance.now();
            running = true;
            requestAnimationFrame(loop);
          }
        });
        img.addEventListener('error', () => {
          loadingEl.textContent = 'Image failed to load';
        });
      });

      // Player class (Dino) with jump and duck; duck affects hitbox
      class Dino {
        constructor() {
          this.w = DINO_TARGET_W;
          this.h = DINO_TARGET_H;
          this.x = 70;
          this.y = groundY - this.h;
          this.vy = 0;
          this.isJumping = false;
          this.isDucking = false;
          this.duckHeight = Math.round(this.h * 0.6);
        }
        getHitbox() {
          const hbH = this.isDucking ? this.duckHeight : this.h;
          // shift hitbox to sit on the ground when ducking
          return { x: this.x, y: this.y + (this.h - hbH), w: this.w, h: hbH };
        }
        jump() {
          if (this.isJumping || this.isDucking) return; // cannot jump while ducking
          this.isJumping = true;
          this.vy = jumpVelocity;
        }
        duck(down) {
          if (this.isJumping && down) return; // don't duck mid-air
          this.isDucking = down;
          // keep feet on ground visually
          this.y = groundY - this.h;
        }
        update(dt) {
          if (this.isJumping) {
            this.vy += gravity * dt;
            this.y += this.vy * dt;
            if (this.y >= groundY - this.h) {
              this.y = groundY - this.h;
              this.vy = 0;
              this.isJumping = false;
            }
          } else {
            this.y = groundY - this.h;
          }
        }
        draw(ctx) {
          // Draw scaled image centered within the current hitbox
          const hb = this.getHitbox();
          const imgW = dinoImage.width;
          const imgH = dinoImage.height;
          const targetW = this.w;
          const targetH = this.isDucking ? this.duckHeight : this.h;
          const scale = Math.min(targetW / imgW, targetH / imgH);
          const drawW = Math.round(imgW * scale);
          const drawH = Math.round(imgH * scale);
          const drawX = hb.x + Math.round((targetW - drawW) / 2);
          const drawY = hb.y + Math.round((targetH - drawH) / 2);
          ctx.drawImage(dinoImage, drawX, drawY, drawW, drawH);
        }
      }

      // Obstacles: Cacti (rects) and Pterodactyls (image)
      class Obstacle {
        constructor(type, speed) {
          this.type = type; // 'cactus' or 'ptero'
          this.speed = speed;
          this.marked = false;
          if (type === 'cactus') {
            // cactus size variability for challenge variety
            this.w = 18 + Math.floor(Math.random() * 12);
            this.h = 26 + Math.floor(Math.random() * 44);
            this.x = canvas.width + Math.random() * 60;
            this.y = groundY - this.h;
          } else {
            // flying enemy
            this.w = PTERO_TARGET_W;
            this.h = PTERO_TARGET_H;
            this.x = canvas.width + Math.random() * 60;
            const minAlt = groundY - 160;
            const maxAlt = groundY - 80;
            this.y = Math.floor(minAlt + Math.random() * (maxAlt - minAlt));
            // Select the image URL from array (single item for now)
            this.img = pteroImage;
          }
        }
        update(dt) {
          this.x -= this.speed * dt;
          if (this.x + this.w < 0) this.marked = true;
        }
        draw(ctx) {
          if (this.type === 'cactus') {
            ctx.fillStyle = '#2e7d32';
            ctx.fillRect(this.x, this.y, this.w, this.h);
            // little arms
            ctx.fillRect(this.x - 6, this.y + 8, 6, 14);
            ctx.fillRect(this.x + this.w, this.y + 12, 6, 16);
          } else {
            const imgW = this.img.width;
            const imgH = this.img.height;
            const scale = Math.min(this.w / imgW, this.h / imgH);
            const drawW = Math.round(imgW * scale);
            const drawH = Math.round(imgH * scale);
            const drawX = this.x + Math.round((this.w - drawW) / 2);
            const drawY = this.y + Math.round((this.h - drawH) / 2);
            ctx.drawImage(this.img, drawX, drawY, drawW, drawH);
          }
        }
        hitbox() {
          return { x: this.x, y: this.y, w: this.w, h: this.h };
        }
      }

      // AABB collision detection
      function rectsIntersect(a, b) {
        return (
          a.x < b.x + b.w &&
          a.x + a.w > b.x &&
          a.y < b.y + b.h &&
          a.y + a.h > b.y
        );
      }

      // Game state
      let dino;
      let obstacles = [];
      let speed;
      let spawnTimer = 0;
      let spawnInterval = 1.25; // seconds between spawns (will adjust with speed)
      let score = 0;
      let high = 0;
      let running = false;
      let lastTime = 0;
      let gameOver = false;

      function resetGame() {
        dino = new Dino();
        obstacles = [];
        speed = initialSpeed;
        spawnTimer = 0;
        spawnInterval = 1.25;
        score = 0;
        gameOver = false;
        overlayEl.classList.add('hidden');
        scoreEl.textContent = '0';
      }

      function spawnObstacle() {
        const roll = Math.random();
        const type = roll < 0.65 ? 'cactus' : 'ptero';
        obstacles.push(new Obstacle(type, speed));
      }

      function update(dt) {
        // increase speed over time
        speed = Math.min(maxSpeed, speed + speedIncreasePerSecond * dt);

        // spawn pacing slightly decreases with speed
        spawnTimer += dt;
        const dynamicInterval = Math.max(0.6, spawnInterval - (speed - initialSpeed) / 1000);
        if (spawnTimer >= dynamicInterval) {
          spawnObstacle();
          spawnTimer = 0;
        }

        dino.update(dt);
        obstacles.forEach(o => o.update(dt));
        obstacles = obstacles.filter(o => !o.marked);

        // collisions
        const hb = dino.getHitbox();
        for (let o of obstacles) {
          if (rectsIntersect(hb, o.hitbox())) {
            endGame();
            break;
          }
        }

        // score scales with speed to reward higher difficulty
        score += speed * dt * 0.05;
        scoreEl.textContent = Math.floor(score).toString();
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // ground line
        ctx.strokeStyle = '#555';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, groundY);
        ctx.lineTo(canvas.width, groundY);
        ctx.stroke();

        // parallax dust
        ctx.fillStyle = '#d7d7d7';
        for (let i = 0; i < 24; i++) {
          const x = (i * 80 + (performance.now() / 30) % 80) % canvas.width;
          ctx.fillRect(x, groundY - 4 - (i % 3), 2, 2);
        }

        dino.draw(ctx);
        obstacles.forEach(o => o.draw(ctx));
      }

      function loop(now) {
        if (!running) return;
        const dt = Math.min(0.033, (now - lastTime) / 1000); // cap dt for stability
        lastTime = now;
        update(dt);
        draw();
        requestAnimationFrame(loop);
      }

      function endGame() {
        running = false;
        gameOver = true;
        if (score > high) high = Math.floor(score);
        highEl.textContent = high.toString();
        messageEl.textContent = 'Game Over';
        overlayEl.classList.remove('hidden');
      }

      function startGame() {
        if (assetsLoaded < 2) return; // guard: wait for images
        resetGame();
        lastTime = performance.now();
        running = true;
        requestAnimationFrame(loop);
      }

      // Controls: Space/Up to jump, Down to duck
      restartBtn.addEventListener('click', () => startGame());

      document.addEventListener('keydown', (e) => {
        if (gameOver && (e.key === ' ' || e.key === 'Space' || e.key === 'Enter')) {
          startGame();
          return;
        }
        if (e.key === ' ' || e.key === 'Space' || e.key === 'ArrowUp') {
          dino.jump();
          e.preventDefault();
        } else if (e.key === 'ArrowDown') {
          dino.duck(true);
          e.preventDefault();
        }
      });
      document.addEventListener('keyup', (e) => {
        if (e.key === 'ArrowDown') {
          dino.duck(false);
          e.preventDefault();
        }
      });

      // If images are already cached, their load events might not fire; handle that case
      if (dinoImage.complete && pteroImage.complete) {
        loadingEl.style.display = 'none';
        startGame();
      }
    </script>
  </body>
</html>
